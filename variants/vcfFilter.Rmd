---
title: "vcfFilter"
author: "Christian Parobek"
date: "November 15, 2014"
output:
  html_document:
    fig_caption: no
    fig_height: 4
    fig_width: 4
---

We want to set quality filters based on the distribution of actual scores observed in our set of SNP calls. This script should be run on a VCF that has been filtred for Neafsey's highly paralogous genes, and TRF intervals. It will plot Allele Frequency, Quality by Depth, Fischer Score, RMS Map Quality, MQ Rank Sum, and Read Position Rank Sum. Finally, at the bottom, it will determine the average depth over all within-exon SNPs and all outside-exon SNPs and plot SNP read-depth distributions by within-exon status.

```{r, echo=FALSE}
# Read in the file
#vcf <- read.table("combined.filtered.vcf", comment.char = "#") #This is just filtered for Neafsey and TRF
vcf <- read.table("combined.pass.vcf", comment.char = "#") #Filtered for FS>10;MQ<60;MQRS<-5;RPRS<-5

# Load the library I need for the regexs I'll use
library("stringr", lib.loc="~/R/x86_64-pc-linux-gnu-library/3.1")
```

Processing `vcf` file...
There are `r length(vcf$V8)` variants in this file that have passed quality filters so far.


####Quality Measure Score Distributions (and allele frequency):

```{r, echo=FALSE}

AF <- str_extract(vcf$V8, "AF=[0123456789.-]+")
AFnum <- as.numeric(str_extract(AF, "[0123456789.-]+"))
plot(sort(AFnum, decreasing=FALSE), xlab="", ylab="Allele Frequency (AF)")
QD <- str_extract(vcf$V8, "QD=[0123456789.-]+")
QDnum <- as.numeric(str_extract(QD, "[0123456789.-]+"))
plot(sort(QDnum, decreasing=FALSE), xlab="", ylab="Quality by Depth (QD)")
FS <- str_extract(vcf$V8, "FS=[0123456789.-]+")
FSnum <- as.numeric(str_extract(FS, "[0123456789.-]+"))
plot(sort(FSnum, decreasing=FALSE), xlab="", ylab="Fisher Score (FS)")
FS <- str_extract(vcf$V8, "FS=[0123456789.-]+")
FSnum <- as.numeric(str_extract(FS, "[0123456789.-]+"))
plot(sort(FSnum, decreasing=FALSE), xlab="", ylab="Fisher Score (FS)")
MQ <- str_extract(vcf$V8, "MQ=[0123456789.-]+")
MQnum <- as.numeric(str_extract(MQ, "[0123456789.-]+"))
plot(sort(MQnum, decreasing=FALSE), xlab="", ylab=" RMS Mapping Quality (MQ)")
MQRankSum <- str_extract(vcf$V8, "MQRankSum=[0123456789.-]+")
MQRankSumnum <- as.numeric(str_extract(MQRankSum, "[0123456789.-]+"))
plot(sort(MQRankSumnum, decreasing=FALSE), xlab="", ylab="MQ Rank Sum")
ReadPosRankSum <- str_extract(vcf$V8, "ReadPosRankSum=[0123456789.-]+")
ReadPosRankSumnum <- as.numeric(str_extract(ReadPosRankSum, "[0123456789.-]+"))
plot(sort(ReadPosRankSumnum, decreasing=FALSE), xlab="", ylab="Read Position Rank Sum")
```

_QD - This is the variant confidence (from the `QUAL` field) divided by the unfiltered depth of non-reference samples. --GATK Documentation_

_FS - Phred-scaled p-value using Fisherâ€™s Exact Test to detect strand bias (the variation being seen on only the forward or only the reverse strand) in the reads. More bias is indicative of false positive calls. --GATK Documentation_

_MQ - Root mean square mapping quality provides an estimation of the overall mapping quality of reads supporting a variant call, averaged over all samples in a cohort. The root mean square is equivalent to the mean of the mapping qualities plus the standard deviation of the mapping qualities. --GATK Documentation_

_Rank-Sum Mapping Quality - This is the u-based z-approximation from the Mann-Whitney Rank Sum Test for mapping qualities (reads with ref bases vs. those with the alternate allele). Note that the mapping quality rank sum test can not be calculated for sites without a mixture of reads showing both the reference and alternate alleles, i.e. this will only be applied to heterozygous calls. --GATK DOcumentation_

_This is the u-based z-approximation from the Mann-Whitney Rank Sum Test for the distance from the end of the read for reads with the alternate allele. If the alternate allele is only seen near the ends of reads, this is indicative of error. Note that the read position rank sum test can not be calculated for sites without a mixture of reads showing both the reference and alternate alleles, i.e. this will only be applied to heterozygous calls. --GATK Documentation_

####Now let's look at read depth over within-exon and outside-exon SNPs:
```{r, echo=FALSE}
ex <- read.table("combined.exons.vcf", comment.char = "#")
  # Read in exon entries
exDepth <- str_extract(ex$V8, "DP=[0123456789.-]+")
  # extract the DP field
exDepth <- as.numeric(str_extract(exDepth, "[0123456789.-]+"))
  # extract the number from the DP field
hist(exDepth, xlim=c(0,8000), ylim=c(0,16000), main="Within-Exon Depth", xlab="Coverage Depth")

nex <- read.table("combined.nonexons.vcf", comment.char = "#")
  # Read in non-exon entries
nexDepth <- str_extract(nex$V8, "DP=[0123456789.-]+")
  # extract the DP field
nexDepth <- as.numeric(str_extract(nexDepth, "[0123456789.-]+"))
  # extract the number from the DP field
hist(nexDepth, xlim=c(0,8000), ylim=c(0,16000), main="Outside-Exon Depth", xlab="Coverage Depth")
```

It appears that the coverage over both coding SNPs and non-coding SNPs is roughly normal. Here are some summary statistics about the coverage:

Number SNPs within exons: `r length(exDepth)`  
Within-exon mean coverage: `r mean(exDepth)`  
Within-exon median coverage: `r median(exDepth)`  
Within-exon maximum coverage: `r max(exDepth)`  
Within-exon minimum coverage: `r min(exDepth)`  

Number SNPs outside exons: `r length(nexDepth)`  
Outside-exon mean coverage: `r mean(nexDepth)`  
Outside-exon median coverage: `r median(nexDepth)`  
Outside-exon maximum coverage: `r max(nexDepth)`  
Outside-exon minimum coverage: `r min(nexDepth)`  

**Conclusions:**  We will be able to use both within-exon and outside-exon SNPs. We will also have to filter by coverage. This step will not remove many SNP entries, but it seems necessary because of the few really low outside-exon SNPs.